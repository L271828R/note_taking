#!/usr/bin/env bash

NOTE_DIR="$NOTES_FOLDERS_PATH"
CURRENT_FILE="$NOTES_CURRENT_FILE"
RESULTS_FILE="$NOTES_RESULTS_FILE"

# 1) Make sure NOTE_DIR exists
if [[ ! -d "$NOTE_DIR" ]]; then
  echo "Error: $NOTE_DIR not found." >&2
  exit 1
fi

# 2) Read the first non-blank line from 'current'
current=""
if [[ -f "$CURRENT_FILE" ]]; then
  current=$(awk 'NR==1 { gsub(/^[ \t]+|[ \t]+$/, ""); print; exit }' "$CURRENT_FILE")
fi

# 3) Determine the target path
if [[ -n "$current" ]]; then
  TARGET="$NOTE_DIR/$current"
  if [[ ! -d "$TARGET" ]]; then
    TARGET="$NOTE_DIR"
  fi
else
  TARGET="$NOTE_DIR"
fi

# 4) Gather and enumerate .md files sorted by update date (newest first)
mapfile -t file_list < <(
  shopt -s nullglob
  for file in "$TARGET"/*.md; do
    if [[ -f "$file" ]]; then
      mod=$(stat -f "%m" "$file")
      name=$(basename "$file")
      echo "$mod|$name"
    fi
  done | sort -n -r
)

# If the script was called with -delete <number>, process deletion.
if [[ "$1" == "-delete" && -n "$2" ]]; then
  delete_index="$2"
  # Check that the provided number is valid
  if (( delete_index < 1 || delete_index > ${#file_list[@]} )); then
    echo "Error: Invalid file number '$delete_index'."
    exit 1
  fi

  # Extract file info; array indices are 0-based
  IFS='|' read -r epoch filename <<< "${file_list[delete_index-1]}"
  file_to_delete="$TARGET/$filename"

  if [[ ! -f "$file_to_delete" ]]; then
    echo "Error: File '$file_to_delete' not found."
    exit 1
  fi

  # Create the deletion directory if it doesn't exist
  delete_dir="/tmp/notes/delete"
  mkdir -p "$delete_dir"

  mv "$file_to_delete" "$delete_dir"
  echo "Moved '$file_to_delete' to '$delete_dir'."
  exit 0
fi

# ANSI escape codes for green and reset
GREEN='\033[0;32m'
RESET='\033[0m'

# 5) Write enumerated list to RESULTS_FILE and print it with the update date in green
{
  for i in "${!file_list[@]}"; do
    IFS='|' read -r epoch filename <<< "${file_list[i]}"
    # Convert epoch to human-readable date (YYYY-MM-DD HH:MM:SS) using BSD date (-r)
    datetime=$(date -r "$epoch" "+%Y-%m-%d %H:%M:%S")
    printf "%d. %s ${GREEN}%s${RESET}\n" $((i+1)) "$filename" "$datetime"
  done
} | tee "$RESULTS_FILE"

